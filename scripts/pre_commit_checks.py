#!/usr/bin/env python3
from __future__ import annotations

import re
import subprocess
import sys
from pathlib import Path

AUDIT_FILE = "SECURITY_ASVS.md"
ASVS_VERSION = "v5.0.0"
ASVS_REF_RE = re.compile(r"\bv5\.0\.0-\d+\.\d+\.\d+\b")

AI_PATTERNS = [
    (re.compile(r"(?i)\blorem ipsum\b"), "placeholder text"),
    (
        re.compile(r"(?i)\bas an ai\b|\bai language model\b|\blanguage model\b"),
        "ai disclaimer",
    ),
    (re.compile(r"(?i)\bgenerated by\b"), "ai disclaimer"),
    (re.compile(r"(?i)\bchatgpt\b|\bcopilot\b|\bclaude\b"), "ai tool mention"),
    (
        re.compile(
            r"(?i)\bto be filled\b|\binsert here\b|\breplace this\b|\bplaceholder\b"
        ),
        "placeholder instruction",
    ),
]

TODO_PATTERN = re.compile(r"\b(TODO|FIXME|WIP)\b")
ALLOWED_TODO = re.compile(r"\b(TODO|FIXME)\s*\((#\d+|[A-Z]+-\d+)\)\b")

TEXT_LIKE_SUFFIXES = {".adoc", ".md", ".rst", ".txt"}
HTML_COMMENT_SUFFIXES = {".htm", ".html", ".md", ".svg", ".xhtml", ".xml"}
SLASH_COMMENT_SUFFIXES = {
    ".c",
    ".cc",
    ".cpp",
    ".cs",
    ".cxx",
    ".dart",
    ".go",
    ".h",
    ".hpp",
    ".hxx",
    ".java",
    ".js",
    ".jsx",
    ".kt",
    ".kts",
    ".m",
    ".mm",
    ".php",
    ".rs",
    ".scala",
    ".swift",
    ".ts",
    ".tsx",
    ".vue",
}
DASH_COMMENT_SUFFIXES = {".sql"}
HASH_COMMENT_SUFFIXES = {
    ".bash",
    ".cfg",
    ".conf",
    ".coveragerc",
    ".dockerignore",
    ".editorconfig",
    ".env",
    ".eslintrc",
    ".flake8",
    ".gitignore",
    ".gitattributes",
    ".ini",
    ".npmrc",
    ".prettierrc",
    ".properties",
    ".ps1",
    ".psd1",
    ".psm1",
    ".pylintrc",
    ".rb",
    ".sh",
    ".stylelintrc",
    ".tf",
    ".tfvars",
    ".toml",
    ".yaml",
    ".yml",
    ".zsh",
}
HASH_COMMENT_NAMES = {
    "gnumakefile",
    "makefile",
    "requirements-dev.txt",
    "requirements.txt",
}

IGNORE_NAMES = {
    AUDIT_FILE,
    "README.md",
    "EXPLICACAO_DIDATICA.md",
    ".pre-commit-config.yaml",
    ".gitignore",
}


def is_binary(data: bytes) -> bool:
    return b"\x00" in data


def get_comment_config(path: Path) -> dict[str, bool]:
    suffix = path.suffix.lower()
    name = path.name.lower()
    is_text = suffix in TEXT_LIKE_SUFFIXES

    line_hash = (
        suffix in HASH_COMMENT_SUFFIXES
        or name in HASH_COMMENT_NAMES
        or name.startswith(".env")
        or name.startswith("dockerfile")
    )
    line_slash = suffix in SLASH_COMMENT_SUFFIXES
    line_dash = suffix in DASH_COMMENT_SUFFIXES
    block_slash = line_slash or line_dash
    html = suffix in HTML_COMMENT_SUFFIXES

    if is_text:
        line_hash = False
        line_slash = False
        line_dash = False
        block_slash = False

    return {
        "line_hash": line_hash,
        "line_slash": line_slash,
        "line_dash": line_dash,
        "block_slash": block_slash,
        "html": html,
    }


def build_comment_ranges(
    line: str,
    config: dict[str, bool],
    state: dict[str, bool],
) -> list[tuple[int, int]]:
    ranges: list[tuple[int, int]] = []
    length = len(line)

    if config["block_slash"]:
        if state["block"]:
            end = line.find("*/")
            if end == -1:
                ranges.append((0, length))
            else:
                ranges.append((0, end + 2))
                state["block"] = False

        if not state["block"]:
            start = line.find("/*")
            if start != -1:
                end = line.find("*/", start + 2)
                if end == -1:
                    ranges.append((start, length))
                    state["block"] = True
                else:
                    ranges.append((start, end + 2))

    if config["html"]:
        if state["html"]:
            end = line.find("-->")
            if end == -1:
                ranges.append((0, length))
            else:
                ranges.append((0, end + 3))
                state["html"] = False

        if not state["html"]:
            start = line.find("<!--")
            if start != -1:
                end = line.find("-->", start + 4)
                if end == -1:
                    ranges.append((start, length))
                    state["html"] = True
                else:
                    ranges.append((start, end + 3))

    if config["line_hash"]:
        pos = line.find("#")
        if pos != -1:
            ranges.append((pos, length))

    if config["line_slash"]:
        pos = line.find("//")
        if pos != -1:
            if pos == 0 or line[pos - 1] != ":":
                ranges.append((pos, length))

    if config["line_dash"]:
        pos = line.find("--")
        if pos != -1:
            ranges.append((pos, length))

    return ranges


def has_disallowed_todo(line: str, ranges: list[tuple[int, int]]) -> bool:
    if not ranges:
        return False

    allowed_spans = [
        (match.start(), match.end()) for match in ALLOWED_TODO.finditer(line)
    ]
    for match in TODO_PATTERN.finditer(line):
        if not any(start <= match.start() < end for start, end in ranges):
            continue
        if any(start <= match.start() < end for start, end in allowed_spans):
            continue
        return True
    return False


def check_file_for_slop(path: Path) -> list[str]:
    if path.name == "pre_commit_checks.py":
        return []
    try:
        data = path.read_bytes()
    except OSError:
        return []

    if is_binary(data):
        return []

    try:
        text = data.decode("utf-8")
    except UnicodeDecodeError:
        text = data.decode("utf-8", errors="ignore")

    issues: list[str] = []
    comment_config = get_comment_config(path)
    state = {"block": False, "html": False}
    for idx, line in enumerate(text.splitlines(), start=1):
        for pattern, label in AI_PATTERNS:
            if pattern.search(line):
                issues.append(f"{path}:{idx}: {label}")
        comment_ranges = build_comment_ranges(line, comment_config, state)
        if has_disallowed_todo(line, comment_ranges):
            issues.append(f"{path}:{idx}: TODO/FIXME/WIP without issue reference")
    return issues


def run_anti_slop(argv: list[str]) -> int:
    if not argv:
        return 0

    all_issues: list[str] = []
    for raw in argv:
        path = Path(raw)
        if not path.exists() or path.is_dir():
            continue
        all_issues.extend(check_file_for_slop(path))

    if not all_issues:
        return 0

    print("anti-slop check failed:")
    for issue in all_issues:
        print(f"- {issue}")
    return 1


def is_security_relevant(path: Path) -> bool:
    if path.name in IGNORE_NAMES:
        return False
    if path.suffix.lower() == ".md":
        return False
    return True


def load_text(path: Path) -> str:
    try:
        return path.read_text(encoding="utf-8")
    except OSError:
        return ""
    except UnicodeDecodeError:
        return path.read_text(encoding="utf-8", errors="ignore")


def validate_audit(path: Path) -> list[str]:
    text = load_text(path)
    issues: list[str] = []
    if not text:
        issues.append(f"{AUDIT_FILE} is empty or unreadable")
        return issues
    if f"ASVS version: {ASVS_VERSION}" not in text:
        issues.append(f"{AUDIT_FILE} must include 'ASVS version: {ASVS_VERSION}'")
    if not ASVS_REF_RE.search(text):
        issues.append(
            f"{AUDIT_FILE} must include at least one ASVS reference like '{ASVS_VERSION}-1.2.5'"
        )
    return issues


def get_changed_files(argv: list[str]) -> list[Path]:
    files: list[Path] = []
    for raw in argv:
        path = Path(raw)
        if path.exists() and not path.is_dir():
            files.append(path)

    git_files: list[Path] = []
    try:
        result = subprocess.run(
            ["git", "diff", "--name-only", "--cached"],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
            check=False,
        )
    except OSError:
        result = None

    if result and result.returncode == 0:
        for line in result.stdout.splitlines():
            line = line.strip()
            if line:
                git_files.append(Path(line))

    return git_files if git_files else files


def run_asvs_audit(argv: list[str]) -> int:
    repo_root = Path.cwd()
    audit_path = repo_root / AUDIT_FILE
    if not audit_path.exists():
        print(f"{AUDIT_FILE} is required for ASVS audit tracking.")
        return 1

    changed_files = get_changed_files(argv)

    security_relevant = any(is_security_relevant(path) for path in changed_files)
    audit_updated = any(path.name == AUDIT_FILE for path in changed_files)

    if security_relevant and not audit_updated:
        print(
            "ASVS audit required: update SECURITY_ASVS.md when security-relevant files change."
        )
        return 1

    issues = validate_audit(audit_path)
    if issues:
        print("ASVS audit check failed:")
        for issue in issues:
            print(f"- {issue}")
        return 1

    return 0


def main(argv: list[str]) -> int:
    if not argv:
        print("Usage: pre_commit_checks.py <anti-slop|asvs-audit> [files...]")
        return 1

    mode = argv[0]
    files = argv[1:]

    if mode == "anti-slop":
        return run_anti_slop(files)
    if mode == "asvs-audit":
        return run_asvs_audit(files)

    print("Usage: pre_commit_checks.py <anti-slop|asvs-audit> [files...]")
    return 1


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
